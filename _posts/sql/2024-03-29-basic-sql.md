---
layout: post
title:  "Basic SQL"
date:   2024-03-29 00:18:23 +0700
categories: [sql]
usemathjax: true
---

Let's say we have a table called `Logins` that contains the following columns:

| Logins     |
|:-----------|
| user_id    |
| login_date |
| time_spent |

- What is the total time that each user spent for the month of Feb, 2024?
```sql
SELECT user_id, SUM(time_spent) AS total_time_spent
FROM Logins
WHERE DATE_FORMAT(login_date, '%Y-%m') = '2024-02'
GROUP BY 1;
```

- Which user(s) have logged in the most number of times for a given day?
```sql
WITH LoginsPerDay AS (
  SELECT user_id, login_date, COUNT(1) AS num_logins
  FROM Logins 
  GROUP BY 1, 2;
)
SELECT DISTINCT(user_id) AS user_id
FROM LoginsPerDay
WHERE num_logins = (SELECT MAX(num_logins) FROM LoginsPerDay)
```


- Which users have logged in for at least 5 consecutive days?
To answer this, we need to do a self-join where for any given row in the first table, we check
if there are rows in the second table that are within 5 days (including itself). Now there can be 
multiple logins on some day; hence we need to dedup using *DISTINCT*.
```sql
WITH LoginWindows AS (
  SELECT 
      l1.user_id,
      l1.login_date,
      COUNT(DISTINCT l2.login_date) AS logins_in_5_days
  FROM Logins l1
  JOIN Logins l2
    ON l1.user_id = l2.user_id
    AND l2.login_date BETWEEN l1.login_date AND DATE_ADD(l1.login_date, INTERVAL 4 DAY)
  GROUP BY l1.user_id, l1.login_date
)
SELECT DISTINCT user_id
FROM LoginWindows
WHERE logins_in_5_days = 5;
```

Let us now consider a table called `Friends` that contains the following columns:

| Friends    |
|:-----------|
| user1_id   |
| user2_id   |

Each row is ordered such that `user1_id` < `user2_id`.

- Calculate number of friends each user has?
Since a given row `(1, 2)` implies that both `user1_id` and `user2_id` have increased their friend 
count by 1; we need to somehow capture the information present in both these columns into a single 
column. We can do this using *UNION*.
```sql
WITH Connections AS (
    SELECT user1_id AS person FROM Friends
    UNION ALL
    SELECT user2_id FROM Friends
)
SELECT person, COUNT(1) AS num_friends
FROM Connections
GROUP BY 1
```

- Calculate number of mutual friends for each friend pair?
A mutual friend of a pair $A \leftrightarrow B$ is someone such that $A \leftrightarrow C$ and $C \leftrightarrow B$. Thus to find the mutual friends we need to do self-join twice. Since the given table 
only contains a directed edge $A \rightarrow B$, to create undirected edges we simply replicate the table 
swapping the user_id as follows:
```sql
    WITH Connections AS (
        SELECT user1_id, user2_id FROM Friends
        UNION ALL
        SELECT user2_id, user1_id FROM Friends
    )
```

Now we can apply our *mutual friend* criteria. Note that the first table in the join is the *Friends* table and not the *Connections* table, to avoid double counting and maintain the ordering `user1_id` < `user2_id`.
```sql
SELECT c1.user1_id, c1.user2_id, COUNT(1) AS num_mutual_friends
FROM Friends c1, Connections c2, Connections c3
    WHERE c1.user1_id = c2.user1_id
    AND c2.user2_id = c3.user1_id
    AND c3.user2_id = c1.user2_id
GROUP BY 1, 2;
```